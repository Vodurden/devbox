#!/usr/bin/env bash
set -euo pipefail

SOURCE_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

print_usage() {
  echo "usage: sync-git-repo --repo <repo> --branch <branch> --ref <ref> --target-dir <dir> [--remote <name> <url>] [--cache-dir <dir>]"
  echo
  echo "  --repo             the repo url to sync (e.g. https://github.com/NixOS/nixpkgs.git)"
  echo "  --branch           the name of our local branch"
  echo "  --remote-branch    the remote branch to track"
  echo "  --ref              the reference to checkout, must be an ancestor of branch"
  echo "  --target-dir       the directory to clone into"
  echo "  --cache-dir        if this points to an existing copy of the repo then we will copy from here instead of cloning,"
  echo "  --remote           additional channels to add to the repo, can be given multiple times (optional)"
  echo "                otherwise we will clone to the cache dir first and then copy"
}

# usage: assert_defined <value> <error_if_not_defined>
#
# example: asset_defined "${1:-}" "fatal: an argument must be provided"
#
# Will abort the program with the given error and print the usage if the value is not defined
assert_defined() {
  if [[ "${1:-}" == "" ]]; then
    echo "${2}"
    echo
    print_usage
    exit 1
  fi
}

### Argument Parsing Section
###
### In this section we handle all the flags and prepare the SYNC_* variables

while [ ! $# -eq 0 ]
do
  case "$1" in
    --help | -h)
      print_usage
      exit
      ;;
    --repo)
      assert_defined "${2:-}" "fatal: --repo requires an argument!"
      SYNC_REPO=$2
      shift
      ;;
    --branch)
      assert_defined "${2:-}" "fatal: --branch requires an argument!"
      SYNC_BRANCH=$2
      shift
      ;;
    --remote-branch)
      assert_defined "${2:-}" "fatal: --remote-branch requires an argument!"
      SYNC_REMOTE_BRANCH=$2
      shift
      ;;
    --ref)
      assert_defined "${2:-}" "fatal: --ref requires an argument!"
      SYNC_REF=$2
      shift
      ;;
    --target-dir)
      assert_defined "${2:-}" "fatal: --target-dir requires an argument!"
      SYNC_TARGET_DIR=$2
      shift
      ;;
    --cache-dir)
      assert_defined "${2:-}" "fatal: --cache-dir requires a directory!"
      SYNC_CACHE_DIR=$2
      shift
      ;;
    --remote)
      assert_defined "${2:-}" "fatal: --remote requires a name"
      assert_defined "${3:-}" "fatal: --remote requires a url"
      SYNC_REMOTES="${SYNC_REMOTES:-} ${2} ${3}"
      shift
      shift
      ;;
    *)
      echo "warning: unknown argument $1. ignoring."
      shift
      ;;
  esac
  shift
done

assert_defined "${SYNC_REPO:-}" "fatal: --repo must be provided"
assert_defined "${SYNC_BRANCH:-}" "fatal: --branch must be provided"
assert_defined "${SYNC_REMOTE_BRANCH:-}" "fatal: --remote-branch must be provided"
assert_defined "${SYNC_REF:-}" "fatal: --ref must be provided"
assert_defined "${SYNC_TARGET_DIR:-}" "fatal: --target-dir must be provided"

### Execution Section
###
### At this point we assume the arguments we have are valid and all the required fields
### are available. Now we need to actually do our job.

# usage: clone_and_fetch_remotes <repo> <target_dir>
#
# Clones the given repo to the directory if it does not already exist. Adds any remotes specified
# by SYNC_REMOTES and fetches them.
clone_and_fetch_remotes() {
  local clone_repo=$1
  local clone_target_dir=$2
  if [[ ! -d "${clone_target_dir}" ]]; then
    echo "No ${clone_target_dir} found. Cloning ${clone_repo}..."
    git clone "${clone_repo}" "${clone_target_dir}"
  fi

  local remotes=(${SYNC_REMOTES:-})
  while [[ "${#remotes[@]}" -gt 0 ]]; do
    local remote_name="${remotes[0]}"
    local remote_url="${remotes[1]}"
    if ! git -C "${clone_target_dir}" config remote.${remote_name}.url > /dev/null; then
      echo "Adding '${remote_name}' remote targeting ${remote_url}"
      git -C "${clone_target_dir}" remote add "${remote_name}" "${remote_url}"
    fi
    remotes=("${remotes[@]:2}")
  done

  echo "Fetching all remotes"
  git -C "${clone_target_dir}" fetch --all --tags
}

# usage: checkout_or_create_branch <dir> <branch>
#
# Checks out the given branch if it exists, or creates it and checks it out if it does exist.
checkout_or_create_branch() {
  local git_dir=$1
  local branch=$2
  if git -C "${git_dir}" show-ref --verify --quiet refs/heads/${branch}; then
    echo "Using existing branch '${branch}'"
    git -C "${git_dir}" checkout ${branch}
  else
    echo "No branch '${branch}' found. Creating..."
    git -C "${git_dir}" checkout -b ${branch}
  fi;
}

echo "Synchronizing ${SYNC_REPO} to ${SYNC_TARGET_DIR}"

# Ensure SYNC_CACHE_DIR exists
if [[ "${SYNC_CACHE_DIR:-}" != "" ]]; then
  echo "Using ${SYNC_CACHE_DIR} as cache directory"
  if [[ ! -d "${SYNC_CACHE_DIR}" ]]; then
    clone_and_fetch_remotes "${SYNC_REPO}" "${SYNC_CACHE_DIR}"
  fi
fi

# Ensure SYNC_TARGET_DIR exists, either from the cache or by cloning
if [[ ! -d "${SYNC_TARGET_DIR}" ]]; then
  if [[ "${SYNC_CACHE_DIR:-}" != "" ]]; then
    echo "No target ${SYNC_TARGET_DIR} found. Copying from ${SYNC_CACHE_DIR}"
    cp -r "${SYNC_CACHE_DIR}" "${SYNC_TARGET_DIR}"
  else
    clone_and_fetch_remotes "${SYNC_REPO}" "${SYNC_TARGET_DIR}"
  fi
else
  echo "Using existing ${SYNC_TARGET_DIR} as target directory"
fi

# Ensure $SYNC_REF actually exists on the remote branch
if ! git -C "${SYNC_TARGET_DIR}" merge-base --is-ancestor "${SYNC_REF}" "${SYNC_REMOTE_BRANCH}"; then
  echo "fatal: ${SYNC_REF} is not on ${SYNC_REMOTE_BRANCH}! Please choose a commit from ${SYNC_REMOTE_BRANCH}"
  exit 1
fi;

echo "Synchronizing branch '${SYNC_BRANCH}' targeting '${SYNC_REMOTE_BRANCH}' at ref ${SYNC_REF}"

# Switch to the branch safely, either by checking out an existing branch or creating a new
# branch. We prefer this to using `git checkout -B` as `-B` can reset the branch and we
# prefer the behavior of `git reset --keep` as it won't accidentally clobber our changes.
checkout_or_create_branch "${SYNC_TARGET_DIR}" "${SYNC_BRANCH}"
git -C "${SYNC_TARGET_DIR}" branch --set-upstream-to "${SYNC_REMOTE_BRANCH}" "${SYNC_BRANCH}"
git -C "${SYNC_TARGET_DIR}" reset --keep "${SYNC_REF}"

echo "${SYNC_TARGET_DIR} syncronized!"
